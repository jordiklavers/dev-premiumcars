// This file was generated by Slater.app - index.js

gsap.registerPlugin(
  ScrollTrigger,
  Draggable,
  CustomEase,
  DrawSVGPlugin,
  SplitText,
  InertiaPlugin
);

let lenis;
let staggerDefault = 0.075;
let durationDefault = 1;
let transitionOffset = 800; /* ms */

const navBarOffset = $(".nav-bar").innerHeight();
const scribbleWidth = "31%";
const scribbleWidthStart = "8%";

const themes = ["blue", "orange", "green", "pink", "maroonred"];
let lastThemeIndex = -1;

function getNonRepeatingRandomTheme() {
  let newIndex;
  do {
    newIndex = Math.floor(Math.random() * themes.length);
  } while (newIndex === lastThemeIndex);
  lastThemeIndex = newIndex;
  return themes[newIndex];
}

CustomEase.create("cubic-default", "0.625, 0.05, 0, 1");
CustomEase.create("cubic-default-scribble", "0.75, 0.15, 0.15, 1");
gsap.defaults({ ease: "cubic-default", duration: durationDefault });

initPageTransitions();

// Animation - Page Loader Short
function initLoaderShort() {
  var tl = gsap.timeline();

  tl.set($(".transition-container"), {
    pointerEvents: "none",
  });

  tl.set(".transition-screen", {
    autoAlpha: 0,
  });

  tl.set($(".transition-scribble path"), {
    drawSVG: "100% 100%",
  });

  tl.set($(".transition-logo"), {
    autoAlpha: 0,
  });

  tl.set($(".transition-scribble path"), {
    strokeWidth: "0%",
    drawSVG: "0% 0%",
  });

  tl.call(
    function () {
      lenis.start();
    },
    null,
    0
  );

  tl.call(
    function () {
      lenis.start();
    },
    null,
    0.1
  );

  tl.call(
    function () {
      pageTransitionOut();
    },
    null,
    0
  );
}

// Animation - Page Loader
function initLoader() {
  var tl = gsap.timeline();

  tl.set($("main"), {
    overflow: "clip",
    height: "100svh",
  });

  tl.set($(".transition-container"), {
    pointerEvents: "all",
  });

  tl.set($(".transition-scribble path"), {
    strokeWidth: scribbleWidth,
  });

  tl.set(
    ".transition-screen",
    {
      autoAlpha: 0.2,
    },
    "<"
  );

  tl.to(
    $(".transition-scribble path"),
    {
      duration: 2,
      drawSVG: "100% 100%",
      ease: "Power2.easeInOut",
    },
    0.25
  );

  tl.to(
    ".transition-screen",
    {
      autoAlpha: 0,
      duration: 2,
      ease: "none",
    },
    "<"
  );

  tl.to(
    $(".transition-scribble path"),
    {
      strokeWidth: scribbleWidthStart,
      duration: 2,
      ease: "cubic-default-scribble",
    },
    "<"
  );

  tl.set(
    $(".transition-logo"),
    {
      autoAlpha: 0,
    },
    "< 0.95"
  );

  tl.set($(".transition-scribble path"), {
    strokeWidth: "0%",
    drawSVG: "0% 0%",
  });

  tl.call(
    function () {
      lenis.stop();
    },
    null,
    0
  );

  tl.call(
    function () {
      pageTransitionOut();
    },
    null,
    0.5
  );
}

// Animation - Page Leave
function pageTransitionIn() {
  var tl = gsap.timeline();

  if (document.querySelector(".lorem-ipsum")) {
  }

  tl.set($(".transition-container"), {
    pointerEvents: "all",
  });

  tl.set($(".transition-screen"), {
    autoAlpha: 0,
  });

  tl.set($(".transition-scribble path"), {
    strokeWidth: scribbleWidthStart,
    drawSVG: "0% 0%",
  });

  tl.to($(".transition-scribble path"), {
    duration: 0.8,
    drawSVG: "0% 100%",
    ease: "Power1.easeInOut",
  });

  tl.to(
    $(".transition-scribble path"),
    {
      strokeWidth: scribbleWidth,
      duration: 0.8,
      ease: "Power2.easeInOut",
    },
    "<"
  );

  tl.to($(".transition-scribble path"), {
    duration: 1.5,
    drawSVG: "100% 100%",
    ease: "Power2.easeInOut",
  });

  tl.to(
    $(".transition-scribble path"),
    {
      strokeWidth: scribbleWidthStart,
      duration: 1.5,
      ease: "cubic-default-scribble",
    },
    "<"
  );

  tl.set($(".transition-scribble path"), {
    strokeWidth: "0%",
    drawSVG: "0% 0%",
  });

  tl.set(
    $(".transition-logo"),
    {
      autoAlpha: 1,
    },
    "0.4"
  );

  tl.set(
    $(".transition-logo"),
    {
      autoAlpha: 0,
    },
    "1.5"
  );

  tl.call(
    function () {
      lenis.stop();
      $("[data-transition-theme]").attr(
        "data-transition-theme",
        getNonRepeatingRandomTheme()
      );
    },
    null,
    0
  );
}

// Animation - Page Enter
function pageTransitionOut() {
  var tl = gsap.timeline();

  if (document.querySelector("[data-split-words]")) {
    tl.from(
      $("[data-split-words] .word"),
      {
        scale: 0,
        duration: 1,
        stagger: 0.05,
        ease: "Expo.easeOut",
      },
      "0.9"
    );

    tl.from(
      $("[data-split-words] .word"),
      {
        xPercent: 100,
        rotate: 0.001,
        duration: 1,
        stagger: 0.05,
        ease: "elastic.out(1,0.75)",
      },
      "<"
    );
  }

  if (document.querySelector(".work-single-header")) {
    tl.from(
      $(".work-single-header .tag, .work-single-header .type"),
      {
        scale: 0,
        x: "8em",
        rotate: 45,
        duration: 1,
        stagger: 0.2,
        ease: "elastic.out(1,0.75)",
      },
      "1"
    );
  }

  if (document.querySelector(".home-header")) {
    tl.from(
      $("[data-transition-words] [data-single-word]"),
      {
        scale: 0,
        duration: 1,
        stagger: 0.05,
        ease: "Expo.easeOut",
      },
      "0.9"
    );

    tl.from(
      $("[data-transition-words] [data-single-word]"),
      {
        xPercent: 100,
        rotate: 0.001,
        duration: 1,
        stagger: 0.05,
        ease: "elastic.out(1,0.75)",
      },
      "<"
    );

    tl.from(
      $("[data-transition-words] .home-header__smiley-svg"),
      {
        xPercent: 100,
        rotate: 360,
        duration: 1.5,
        ease: "elastic.out(1,0.75)",
      },
      "< 0.1"
    );

    tl.from(
      $("[data-transition-words] .home-header__title-line-svg path"),
      {
        drawSVG: "100% 100%",
        duration: 1.5,
      },
      "< 0.1"
    );

    tl.from(
      $("[data-transition-words] .home-header__star-inner"),
      {
        yPercent: 100,
        scale: 0,
        rotate: -180,
        duration: 1.5,
        ease: "elastic.out(1,0.75)",
      },
      "< 0.3"
    );
  }

  if (document.querySelector(".work-header")) {
    tl.from(
      $(".work-intro__arrow-svg path"),
      {
        drawSVG: "0% 0%",
        duration: 1.5,
      },
      "0.8"
    );
  }

  tl.call(
    function () {
      lenis.stop();
    },
    null,
    0
  );

  tl.call(
    function () {
      lenis.start();

      gsap.set($(".transition-container"), {
        clearProps: "all",
      });

      gsap.set($("main"), {
        clearProps: "all",
      });
    },
    null,
    1.6
  );

  tl.call(
    function () {
      $("[data-transition]").attr("data-transition", "not-active");
    },
    null,
    0.3
  );
}

function initPageTransitions() {
  // # Common: leave (Before Offset)
  async function commonLeaveBeforeOffset(data) {
    pageTransitionIn(data.current);
    destroyCustomCursor();
  }

  // # Common: leave (After Offset)
  async function commonLeaveAfterOffset(data) {
    lenis.destroy();
    killAllScrollTriggers();
    data.current.container.remove();
    $("[data-scrolling-direction]").attr("data-scrolling-direction", "down");
    $("[data-scrolling-started]").attr("data-scrolling-started", "false");
    $("[data-modal-work-status]").attr("data-modal-work-status", "not-active");
    $("[data-modal-whatsapp-status]").attr(
      "data-modal-whatsapp-status",
      "not-active"
    );
    $("[data-transition]").attr("data-transition", "active");
  }

  // # Common: enter
  async function commonEnter(data) {
    initBarbaNavUpdate(data);
    pageTransitionOut(data.next);
  }

  // # Common: beforeEnter
  async function commonBeforeEnter(data) {
    ScrollTrigger.getAll().forEach((t) => t.kill());
    initResetWebflow(data);

    initSmoothScroll(data.next.container);
    initScript();
  }

  // # Common: afterEnter
  async function commonAfterEnter(data) {
    window.scrollTo(0, 0);
    ScrollTrigger.refresh();
  }

  barba.init({
    sync: true,
    debug: true,
    timeout: 7000,
    preventRunning: true,
    prevent: function ({ el }) {
      if (el.hasAttribute("data-barba-prevent")) {
        return true;
      }
    },
    transitions: [
      {
        name: "self",
        async leave(data) {
          await commonLeaveBeforeOffset(data);
          await delay(transitionOffset);
          await commonLeaveAfterOffset(data);
        },
        async enter(data) {
          await commonEnter(data);
        },
        async beforeEnter(data) {
          await commonBeforeEnter(data);
        },
        async afterEnter(data) {
          await commonAfterEnter(data);
        },
      },
      {
        name: "default",
        once(data) {
          document.fonts.ready.then(function () {
            initSmoothScroll(data.next.container);
            initScript();
            initLoader();
          });
        },
        async leave(data) {
          await commonLeaveBeforeOffset(data);
          await delay(transitionOffset);
          await commonLeaveAfterOffset(data);
        },
        async enter(data) {
          await commonEnter(data);
        },
        async beforeEnter(data) {
          await commonBeforeEnter(data);
        },
        async afterEnter(data) {
          await commonAfterEnter(data);
        },
      },
    ],
  });

  function initSmoothScroll(container) {
    initLenis();
    ScrollTrigger.refresh();
  }

  // Function to kill all ScrollTrigger data
  function killAllScrollTriggers() {
    if (typeof ScrollTrigger !== "undefined") {
      ScrollTrigger.killAll(); // Kill all ScrollTrigger instances
    }
  }

  // Reset scroll on page next
  history.scrollRestoration = "manual";
}

function initLenis() {
  // Lenis: https://github.com/studio-freight/lenis
  lenis = new Lenis({
    // duration: 1,
    lerp: 0.165,
    wheelMultiplier: 1.25,
  });

  lenis.on("scroll", ScrollTrigger.update);

  gsap.ticker.add((time) => {
    lenis.raf(time * 1000);
  });

  gsap.ticker.lagSmoothing(0);
}

// Don't touch
function delay(n) {
  n = n || 2000;
  return new Promise((done) => {
    setTimeout(() => {
      done();
    }, n);
  });
}

/**
 * Fire all scripts on page load
 */
function initScript() {
  initCheckWindowHeight();
  initBasicFunctions();
  initMarqueeScrollDirection();
  initVimeoThumbnailVideo();
  initVimeoPlayer();
  initSplitText();
  // initLenisCheckScrollUpDown();
  initScrollToAnchorLenis();
  initCheckTheme();
  initGenerateQRCode();
  initCustomCursor();
  initMWG11();
  initMWG25();
  initMomentumBasedCardsHover();
  initFlickCards();
  initTeamGridCycle();
  initCSSMarquee();
  initBasicGSAPSlider();
  initScrolltriggerAnimations();
  initPageLeaveTitle();
  initDisplayCount();
}

/**
 * Reset Webflow
 */
function initResetWebflow(data) {
  let parser = new DOMParser();
  let dom = parser.parseFromString(data.next.html, "text/html");
  let webflowPageId = dom.querySelector("html").getAttribute("data-wf-page");
  document.documentElement.setAttribute("data-wf-page", webflowPageId);
  window.Webflow.destroy();
  window.Webflow.ready();
  // window.Webflow.require("ix2").init();
}

/**
 * Barba Update Links outside Main on page Transition
 */
function initBarbaNavUpdate(data) {
  const updateItems = $(data.next.html).find("[data-barba-update]");

  $("[data-barba-update]").each(function (index) {
    if ($(updateItems[index]).get(0)) {
      const newLinkStatus = $(updateItems[index])
        .get(0)
        .getAttribute("data-link-status");
      $(this).attr("data-link-status", newLinkStatus);
    }
  });
}

/**
 * Window Inner Height Check
 */
function initCheckWindowHeight() {
  // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty("--vh-in-px", `${vh}px`);
}

/**
 * Basic Functions
 */
function initBasicFunctions() {
  // Work Modal
  $('[data-modal-work-action="hover"]')
    .on("mouseenter", function () {
      if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
        if ($("header").attr("data-modal-work-status") === "not-active") {
          $("header").attr("data-modal-work-status", "active");
        }
      }
    })
    .on("mouseleave", function () {
      if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
        if ($("header").attr("data-modal-work-status") === "active") {
          $("header").attr("data-modal-work-status", "not-active");
          lenis.start();
        }
      }
    });

  $('[data-modal-work-action="toggle"]').click(function () {
    if (window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
      if ($("header").attr("data-modal-work-status") === "not-active") {
        $("header").attr("data-modal-work-status", "active");
        lenis.stop();
      } else {
        $("header").attr("data-modal-work-status", "not-active");
        lenis.start();
      }
    }
  });

  $('[data-modal-work-action="close"]').click(function () {
    $("header").attr("data-modal-work-status", "not-active");
    lenis.start();
  });

  // WhatsApp Modal
  $('[data-modal-whatsapp-action="hover"]')
    .on("mouseenter", function () {
      if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
        if ($("header").attr("data-modal-whatsapp-status") === "not-active") {
          $("header").attr("data-modal-whatsapp-status", "active");
        }
      }
    })
    .on("mouseleave", function () {
      if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
        if ($("header").attr("data-modal-whatsapp-status") === "active") {
          $("header").attr("data-modal-whatsapp-status", "not-active");
          lenis.start();
        }
      }
    });

  $('[data-modal-whatsapp-action="toggle"]').click(function () {
    if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
      if ($("header").attr("data-modal-whatsapp-status") === "not-active") {
        $("header").attr("data-modal-whatsapp-status", "active");
        lenis.stop();
      } else {
        $("header").attr("data-modal-whatsapp-status", "not-active");
        lenis.start();
      }
    }
  });

  $('[data-modal-whatsapp-action="close"]').click(function () {
    $("header").attr("data-modal-whatsapp-status", "not-active");
    lenis.start();
  });

  // Key ESC
  $(document).keydown(function (e) {
    if (e.keyCode == 27) {
      $("header").attr("data-modal-work-status", "not-active");
      $("header").attr("data-modal-whatsapp-status", "not-active");
      lenis.start();
    }
  });

  document.querySelectorAll(".draw-btn").forEach(function (drawBtn) {
    const svg = drawBtn.querySelector("svg");
    if (!svg) return;
    const paths = svg.querySelectorAll("path");
    if (paths.length !== 2) return;

    const dur = 0.5;

    gsap.set(paths, { drawSVG: "0% 100%" });

    let tl = null;

    function runAnimation() {
      if (tl) {
        tl.kill();
        gsap.set(paths, { drawSVG: "0% 100%" });
      }

      tl = gsap.timeline();

      tl.to(
        paths[0],
        { drawSVG: "100% 100%", duration: dur * 0.5, ease: "Power2.easeInOut" },
        0
      );
      tl.to(
        paths[1],
        { drawSVG: "100% 100%", duration: dur * 0.5, ease: "Power2.easeInOut" },
        dur * 0.25
      );

      tl.set(paths[0], { drawSVG: "0% 0%" }, dur * 0.5);
      tl.to(paths[0], { drawSVG: "0% 100%", duration: dur }, dur * 0.5);

      tl.set(paths[1], { drawSVG: "0% 0%" }, dur * 0.75);
      tl.to(paths[1], { drawSVG: "0% 100%", duration: dur }, dur * 0.75);
    }

    drawBtn.addEventListener("mouseenter", runAnimation);
    drawBtn.addEventListener("mouseleave", runAnimation);
  });
}

/**
 * Lenis - Check Scroll up or Down
 */

function initLenisCheckScrollUpDown() {
  var lastScrollTop = 0;
  var threshold = 200;
  var thresholdTop = 50;

  var scrollHandler = function (e) {
    var nowScrollTop = e.targetScroll;

    if (Math.abs(lastScrollTop - nowScrollTop) >= threshold) {
      // Check Scroll Direction
      if (nowScrollTop > lastScrollTop) {
        $("[data-scrolling-direction]").attr(
          "data-scrolling-direction",
          "down"
        );
      } else {
        $("[data-scrolling-direction]").attr("data-scrolling-direction", "up");
      }
      lastScrollTop = nowScrollTop;

      // Check if Scroll Started
      if (nowScrollTop > thresholdTop) {
        $("[data-scrolling-started]").attr("data-scrolling-started", "true");
      } else {
        $("[data-scrolling-started]").attr("data-scrolling-started", "false");
      }
    }
  };

  function startCheckScroll() {
    lenis.on("scroll", scrollHandler);
  }

  function stopCheckScroll() {
    lenis.off("scroll", scrollHandler);
  }

  // Initialize the scroll check
  startCheckScroll();

  // Cleanup before leaving the page
  barba.hooks.beforeLeave(() => {
    stopCheckScroll(); // Clean up the scroll event listeners
    lastScrollTop = 0; // Reset scroll tracking data
  });

  // Reinitialize after page transition
  barba.hooks.after(() => {
    startCheckScroll(); // Reattach the scroll event listeners
  });
}

/**
 * Lenis - ScrollTo Anchor Links
 */
function initScrollToAnchorLenis() {
  $("[data-anchor-target]").click(function () {
    let targetScrollToAnchorLenis = $(this).attr("data-anchor-target");
    lenis.scrollTo(targetScrollToAnchorLenis, {
      easing: (x) =>
        x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
      duration: 1,
    });
  });
}

/**
 * Check Theme of Sections
 */
function initCheckTheme() {
  function checkThemeSection() {
    var themeSections = document.querySelectorAll("[data-theme-section]");
    var themeObserverOffset = $(".nav-bar").innerHeight() / 2;

    themeSections.forEach(function (themeSection) {
      var themeSectionTop = themeSection.getBoundingClientRect().top;
      var themeSectionBottom = themeSection.getBoundingClientRect().bottom;

      if (
        themeSectionTop <= themeObserverOffset &&
        themeSectionBottom >= themeObserverOffset
      ) {
        // Check [data-theme-section]
        var themeSectionActive = $(themeSection).attr("data-theme-section");
        if (
          $("[data-theme-nav]").attr("data-theme-nav") !== themeSectionActive
        ) {
          $("[data-theme-nav]").attr("data-theme-nav", themeSectionActive);
        }

        // Check [data-bg-section]
        var bgSectionActive = $(themeSection).attr("data-bg-section");
        if ($("[data-bg-nav]").attr("data-bg-nav") !== bgSectionActive) {
          $("[data-bg-nav]").attr("data-bg-nav", bgSectionActive);
        }
      }
    });
  }

  // Reference to the scroll event handler
  function startThemeCheck() {
    document.addEventListener("scroll", checkThemeSection);
  }

  function stopThemeCheck() {
    document.removeEventListener("scroll", checkThemeSection);
  }

  // Initial check and start listening for scroll events
  checkThemeSection();
  startThemeCheck();

  // Clean up and reset on page transition
  barba.hooks.beforeLeave(() => {
    stopThemeCheck(); // Remove the scroll event listener
  });

  barba.hooks.after(() => {
    checkThemeSection(); // Re-check the theme immediately after the transition
    startThemeCheck(); // Reattach the scroll event listener
  });
}

/**
 * Generate QR Code
 */
function initGenerateQRCode() {
  document.querySelectorAll("[data-qr-code]").forEach((parent) => {
    const url = parent.getAttribute("data-qr-code").trim();
    if (!url) return;

    // Generate an SVG QR via kjua
    const svg = kjua({
      text: url,
      render: "svg", // force SVG output
      crisp: true, // keep edges sharp
      minVersion: 1,
      ecLevel: "M",
      size: 200, // viewBox will be 200×200
      fill: "#000000",
      back: "#FFFFFF",
      rounded: 0,
    });

    // Remove any inline width/height/style so CSS can size it responsively
    svg.removeAttribute("width");
    svg.removeAttribute("height");
    svg.removeAttribute("style");

    // Insert into every [data-qr-code-canvas] inside this parent
    parent.querySelectorAll("[data-qr-code-canvas]").forEach((placeholder) => {
      const clone =
        placeholder === parent.querySelector("[data-qr-code-canvas]")
          ? svg
          : svg.cloneNode(true);
      placeholder.appendChild(clone);
    });

    // Add the link to all elements with [data-whatsapp-modal-link] attribute
    document.querySelectorAll("[data-qr-code-link]").forEach((linkEl) => {
      linkEl.setAttribute("href", url);
      linkEl.setAttribute("target", "_blank");
    });

    // Set href on every [data-qr-code-link] inside this parent
    parent.querySelectorAll("[data-qr-code-link]").forEach((linkEl) => {
      linkEl.setAttribute("href", url);
    });
  });
}

/**
 * Momemtum-based Cards Hover
 */
function initMomentumBasedCardsHover() {
  // If this device can’t hover with a fine pointer, stop here
  if (!window.matchMedia("(hover: hover) and (pointer: fine)").matches) {
    return;
  }

  // Configuration (tweak these for feel)
  const xyMultiplier = 30; // multiplies pointer velocity for x/y movement
  const rotationMultiplier = 20; // multiplies normalized torque for rotation speed
  const inertiaResistance = 200; // higher = stops sooner

  // Pre-build clamp functions for performance
  const clampXY = gsap.utils.clamp(-1080, 1080);
  const clampRot = gsap.utils.clamp(-60, 60);

  // Initialize each root container
  document.querySelectorAll("[data-inertia-init]").forEach((root) => {
    let prevX = 0,
      prevY = 0;
    let velX = 0,
      velY = 0;
    let rafId = null;

    // Track pointer velocity (throttled to RAF)
    root.addEventListener("mousemove", (e) => {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        velX = e.clientX - prevX;
        velY = e.clientY - prevY;
        prevX = e.clientX;
        prevY = e.clientY;
        rafId = null;
      });
    });

    // Attach hover inertia to each child element
    root.querySelectorAll("[data-inertia-element]").forEach((el) => {
      el.addEventListener("mouseenter", (e) => {
        const target = el.querySelector("[data-inertia-child]");
        if (!target) return;

        // Compute offset from center to pointer
        const { left, top, width, height } = target.getBoundingClientRect();
        const centerX = left + width / 2;
        const centerY = top + height / 2;
        const offsetX = e.clientX - centerX;
        const offsetY = e.clientY - centerY;

        // Compute raw torque (px²/frame)
        const rawTorque = offsetX * velY - offsetY * velX;

        // Normalize torque so rotation ∝ pointer speed (deg/sec)
        const leverDist = Math.hypot(offsetX, offsetY) || 1;
        const angularForce = rawTorque / leverDist;

        // Calculate and clamp velocities
        const velocityX = clampXY(velX * xyMultiplier);
        const velocityY = clampXY(velY * xyMultiplier);
        const rotationVelocity = clampRot(angularForce * rotationMultiplier);

        // Apply GSAP inertia tween
        gsap.to(target, {
          inertia: {
            x: { velocity: velocityX, end: 0 },
            y: { velocity: velocityY, end: 0 },
            rotation: { velocity: rotationVelocity, end: 0 },
            resistance: inertiaResistance,
          },
        });
      });
    });
  });
}

/**
 * Vimeo Player Advanced (Osmo)
 */

function initVimeoPlayer() {
  // Select all elements that have [data-vimeo-player-init]
  const vimeoPlayers = document.querySelectorAll("[data-vimeo-player-init]");

  vimeoPlayers.forEach(function (vimeoElement, index) {
    // Add Vimeo URL ID to the iframe [src]
    // Looks like: https://player.vimeo.com/video/1019191082
    const vimeoVideoID = vimeoElement.getAttribute("data-vimeo-video-id");
    if (!vimeoVideoID) return;
    const vimeoVideoURL = `https://player.vimeo.com/video/${vimeoVideoID}?api=1&background=1&autoplay=0&loop=0&muted=1`;
    vimeoElement.querySelector("iframe").setAttribute("src", vimeoVideoURL);

    // Assign an ID to each element
    const videoIndexID = "vimeo-player-advanced-index-" + index;
    vimeoElement.setAttribute("id", videoIndexID);

    const iframeID = vimeoElement.id;
    const player = new Vimeo.Player(iframeID);

    let videoAspectRatio;

    function updateVimeoSizing() {
      const beforeEl = vimeoElement.querySelector(".vimeo-player__before");

      if (vimeoElement.getAttribute("data-vimeo-update-size") === "true") {
        player.getVideoWidth().then(function (width) {
          player.getVideoHeight().then(function (height) {
            if (beforeEl) {
              beforeEl.style.paddingTop = (height / width) * 100 + "%";
            }
          });
        });
      }

      if (vimeoElement.getAttribute("data-vimeo-update-size") === "cover") {
        player.getVideoWidth().then(function (width) {
          player.getVideoHeight().then(function (height) {
            videoAspectRatio = height / width;
            if (beforeEl) {
              beforeEl.style.paddingTop = "0%";
            }
            adjustVideoSizing();
          });
        });
      }
    }

    // Update Aspect Ratio if [data-vimeo-update-size="true"]
    updateVimeoSizing();

    // Function to adjust video sizing (to cover the video)
    function adjustVideoSizing() {
      const containerRatio =
        vimeoElement.offsetHeight / vimeoElement.offsetWidth;

      const iframeWrapper = vimeoElement.querySelector(".vimeo-player__iframe");
      if (iframeWrapper && videoAspectRatio) {
        if (containerRatio > videoAspectRatio) {
          // Container is taller relative to the video
          const widthFactor = containerRatio / videoAspectRatio;
          iframeWrapper.style.width = widthFactor * 100 + "%";
          iframeWrapper.style.height = "100%";
        } else {
          // Container is wider relative to the video
          const heightFactor = videoAspectRatio / containerRatio;
          iframeWrapper.style.height = heightFactor * 100 + "%";
          iframeWrapper.style.width = "100%";
        }
      }
    }

    // Adjust video sizing on resize
    if (vimeoElement.getAttribute("data-vimeo-update-size") === "cover") {
      window.addEventListener("resize", adjustVideoSizing);
    }

    // Loaded & play
    player.on("play", function () {
      vimeoElement.setAttribute("data-vimeo-loaded", "true");
      vimeoElement.setAttribute("data-vimeo-playing", "true");
      updateVimeoSizing();
    });

    // Autoplay
    if (vimeoElement.getAttribute("data-vimeo-autoplay") === "false") {
      // Autoplay = false
      player.setVolume(1);
      player.pause();
    } else {
      // Autoplay = true
      player.setVolume(0);
      vimeoElement.setAttribute("data-vimeo-muted", "true");

      // If paused-by-user === false, do scroll-based autoplay
      if (vimeoElement.getAttribute("data-vimeo-paused-by-user") === "false") {
        function checkVisibility() {
          const rect = vimeoElement.getBoundingClientRect();
          const inView = rect.top < window.innerHeight && rect.bottom > 0;
          inView ? vimeoPlayerPlay() : vimeoPlayerPause();
        }

        // Initial check
        checkVisibility();

        // Handle scroll
        window.addEventListener("scroll", checkVisibility);
      }
    }

    // Function: Play Video
    function vimeoPlayerPlay() {
      vimeoElement.setAttribute("data-vimeo-activated", "true");
      vimeoElement.setAttribute("data-vimeo-playing", "true");
      player.play().catch((err) => {
        if (err.name !== "PlayInterrupted") console.error(err);
      });
    }

    // Function: Pause Video
    function vimeoPlayerPause() {
      player.pause();
    }

    // Paused
    player.on("pause", function () {
      vimeoElement.setAttribute("data-vimeo-playing", "false");
    });

    // Click: Play
    const playBtn = vimeoElement.querySelector('[data-vimeo-control="play"]');
    if (playBtn) {
      playBtn.addEventListener("click", function () {
        // Always set volume to 0 first to avoid pop
        player.setVolume(0);
        vimeoPlayerPlay();

        // If muted attribute is 'true', keep volume at 0, else 1
        if (vimeoElement.getAttribute("data-vimeo-muted") === "true") {
          player.setVolume(0);
        } else {
          player.setVolume(1);
        }
      });
    }

    // Click: Pause
    const pauseBtn = vimeoElement.querySelector('[data-vimeo-control="pause"]');
    if (pauseBtn) {
      pauseBtn.addEventListener("click", function () {
        vimeoPlayerPause();
        // If paused by user => kill the scroll-based autoplay
        if (vimeoElement.getAttribute("data-vimeo-autoplay") === "true") {
          vimeoElement.setAttribute("data-vimeo-paused-by-user", "true");
          // Removing scroll listener (if you’d like)
          window.removeEventListener("scroll", checkVisibility);
        }
      });
    }

    // Find the closest <section> around the vimeoElement
    const vimeoParent = vimeoElement.closest("[data-vimeo-parent]");
    if (!vimeoParent) return;

    // Find all mute buttons within that section
    const muteButtons = vimeoParent.querySelectorAll(
      '[data-vimeo-control="mute"]'
    );

    muteButtons.forEach((muteBtn) => {
      muteBtn.addEventListener("click", function () {
        const isMuted =
          vimeoElement.getAttribute("data-vimeo-muted") === "true";

        player.setVolume(isMuted ? 1 : 0);
        vimeoElement.setAttribute(
          "data-vimeo-muted",
          isMuted ? "false" : "true"
        );
      });
    });

    // Fullscreen
    // Check if Fullscreen API is supported
    const fullscreenSupported = !!(
      document.fullscreenEnabled ||
      document.webkitFullscreenEnabled ||
      document.mozFullScreenEnabled ||
      document.msFullscreenEnabled
    );

    const fullscreenBtn = vimeoElement.querySelector(
      '[data-vimeo-control="fullscreen"]'
    );

    // Hide the fullscreen button if not supported
    if (!fullscreenSupported && fullscreenBtn) {
      fullscreenBtn.style.display = "none";
    }

    if (fullscreenBtn) {
      fullscreenBtn.addEventListener("click", () => {
        const fullscreenElement = document.getElementById(iframeID);
        if (!fullscreenElement) return;

        const isFullscreen =
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;

        if (isFullscreen) {
          // Exit fullscreen
          vimeoElement.setAttribute("data-vimeo-fullscreen", "false");
          (
            document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen
          ).call(document);
        } else {
          // Enter fullscreen
          vimeoElement.setAttribute("data-vimeo-fullscreen", "true");
          (
            fullscreenElement.requestFullscreen ||
            fullscreenElement.webkitRequestFullscreen ||
            fullscreenElement.mozRequestFullScreen ||
            fullscreenElement.msRequestFullscreen
          ).call(fullscreenElement);
        }
      });
    }

    const handleFullscreenChange = () => {
      const isFullscreen =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement;

      vimeoElement.setAttribute(
        "data-vimeo-fullscreen",
        isFullscreen ? "true" : "false"
      );
    };

    // Add event listeners for fullscreen changes (with vendor prefixes)
    [
      "fullscreenchange",
      "webkitfullscreenchange",
      "mozfullscreenchange",
      "msfullscreenchange",
    ].forEach((event) => {
      document.addEventListener(event, handleFullscreenChange);
    });

    // Video Ended
    function vimeoOnEnd() {
      if (vimeoElement.getAttribute("data-vimeo-autoplay") === "false") {
        vimeoElement.setAttribute("data-vimeo-activated", "false");
        vimeoElement.setAttribute("data-vimeo-playing", "false");
        player.unload();
      } else {
        player.play();
      }
    }
    player.on("ended", vimeoOnEnd);
  });
}

/**
 * Custom Cursor
 */

let customCursorObserverList = [];
let customCursorMouseMoveHandler;
let customCursorTicker;
let customCursorHoverElements = [];
let customCursorIdleTimeout;
let hoveredCustomEl = null;

function initCustomCursor() {
  if (window.matchMedia("(hover: none) and (pointer: coarse)").matches) return;
  const cursor = document.querySelector("[data-cursor-init]");
  if (!cursor) return;
  cursor.setAttribute("data-cursor-init", "true");

  const cursorPos = { x: innerWidth / 2, y: innerHeight / 2 };
  const mousePos = { x: cursorPos.x, y: cursorPos.y };
  const speed = 0.15;
  const xSet = gsap.quickSetter(cursor, "x", "px");
  const ySet = gsap.quickSetter(cursor, "y", "px");

  function setCursorType(el) {
    const type = el.dataset.customCursor;
    if (type === "mute") {
      const wrapper = el.closest("[data-vimeo-muted]");
      if (!wrapper) return;
      const playing = wrapper.dataset.vimeoPlaying === "true";
      const loaded = wrapper.dataset.vimeoLoaded === "true";
      if (playing && loaded) {
        const state = wrapper.dataset.vimeoMuted === "true";
        cursor.setAttribute(
          "data-cursor-type",
          state ? "mute-true" : "mute-false"
        );
      }
    } else {
      cursor.setAttribute("data-cursor-type", type);
    }
  }

  function hideCursorType() {
    const current = cursor.getAttribute("data-cursor-type");
    if (current === "mute-true") {
      cursor.setAttribute("data-cursor-type", "mute-true-hidden");
    } else if (current === "mute-false") {
      cursor.setAttribute("data-cursor-type", "mute-false-hidden");
    }
  }

  customCursorMouseMoveHandler = (e) => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
    clearTimeout(customCursorIdleTimeout);
    if (hoveredCustomEl) {
      setCursorType(hoveredCustomEl);
      if (hoveredCustomEl.dataset.customCursor === "mute") {
        customCursorIdleTimeout = setTimeout(hideCursorType, 1000);
      }
    }
  };
  window.addEventListener("mousemove", customCursorMouseMoveHandler);

  function tick() {
    const dt = 1 - Math.pow(1 - speed, gsap.ticker.deltaRatio());
    cursorPos.x += (mousePos.x - cursorPos.x) * dt;
    cursorPos.y += (mousePos.y - cursorPos.y) * dt;
    xSet(cursorPos.x);
    ySet(cursorPos.y);
  }
  gsap.ticker.add(tick);
  customCursorTicker = tick;

  document.querySelectorAll("[data-custom-cursor]").forEach((el) => {
    const onEnter = () => {
      hoveredCustomEl = el;
      setCursorType(el);
      clearTimeout(customCursorIdleTimeout);
    };

    const onLeave = () => {
      if (hoveredCustomEl === el) hoveredCustomEl = null;
      cursor.setAttribute("data-cursor-type", "false");
      clearTimeout(customCursorIdleTimeout);
    };

    const onClick = () => {
      if (el.dataset.customCursor === "mute") {
        setCursorType(el);
        clearTimeout(customCursorIdleTimeout);
        customCursorIdleTimeout = setTimeout(hideCursorType, 1000);
      }
    };

    el.addEventListener("mouseenter", onEnter);
    el.addEventListener("mouseleave", onLeave);
    el.addEventListener("click", onClick);
    customCursorHoverElements.push({ el, onEnter, onLeave, onClick });

    if (el.dataset.customCursor === "mute") {
      const wrapper = el.closest("[data-vimeo-muted]");
      if (wrapper) {
        const observer = new MutationObserver((mutations) => {
          if (!el.matches(":hover")) return;
          for (const m of mutations) {
            if (
              m.type === "attributes" &&
              m.attributeName === "data-vimeo-muted"
            ) {
              setCursorType(el);
              clearTimeout(customCursorIdleTimeout);
              customCursorIdleTimeout = setTimeout(hideCursorType, 1000);
            }
          }
        });
        observer.observe(wrapper, {
          attributes: true,
          attributeFilter: ["data-vimeo-muted"],
        });
        customCursorObserverList.push(observer);
      }
    }
  });
}

function destroyCustomCursor() {
  const cursor = document.querySelector("[data-cursor-init]");
  if (!cursor) return;
  window.removeEventListener("mousemove", customCursorMouseMoveHandler);
  gsap.ticker.remove(customCursorTicker);
  clearTimeout(customCursorIdleTimeout);

  customCursorHoverElements.forEach(({ el, onEnter, onLeave, onClick }) => {
    el.removeEventListener("mouseenter", onEnter);
    el.removeEventListener("mouseleave", onLeave);
    el.removeEventListener("click", onClick);
  });
  customCursorHoverElements = [];

  customCursorObserverList.forEach((observer) => observer.disconnect());
  customCursorObserverList = [];

  hoveredCustomEl = null;
  cursor.removeAttribute("data-cursor-type");
  cursor.setAttribute("data-cursor-init", "false");
}

/**
 * Split Text
 */
function initSplitText() {
  document.fonts.ready.then(function () {
    $("[data-split-words]").each(function () {
      SplitText.create($(this), {
        type: "words",
        wordsClass: "word",
      });
    });
  });
}

/**
 * MWG 11
 */
function initMWG11() {
  // https://madewithgsap.com/effects/tutorial011

  document.fonts.ready.then(function () {
    $(".horizontal-words").each(function () {
      var $container = $(this);

      // split the heading into characters
      var $h2 = $container.find(".horizontal-words__h2");
      if ($h2.length) {
        SplitText.create($h2[0], {
          type: "chars",
          charsClass: "letter",
        });
      }

      var $text = $container.find(".horizontal-words__relative");
      var $letters = $container.find(".letter");
      var $stickers = $container.find(".horizontal-words__sticker-svg");
      var $arrow = $container.find(
        ".horizontal-words__arrow-svg path, .horizontal-words__arrow-end-svg path"
      );

      // if the main text element isn't found, skip this container
      if (!$text.length) {
        console.warn(
          "initMWG11: .horizontal-words__relative element not found in one of the containers"
        );
        return;
      }

      // calculate how far the text needs to move (fallback to 0 if undefined)
      var textWidth = $text[0].clientWidth || 0;
      var bodyWidth = document.body.clientWidth || 0;
      var distance = textWidth - bodyWidth;

      var scrollTween = gsap.fromTo(
        $text,
        {
          xPercent: 50,
        },
        {
          xPercent: -100,
          ease: "none",
          scrollTrigger: {
            trigger: $container[0],
            start: "-30% top",
            end: "125% bottom",
            scrub: 0.5,
          },
        }
      );

      $letters.each(function () {
        gsap.from(this, {
          yPercent: (Math.random() - 0.5) * 500,
          rotation: (Math.random() - 0.5) * 60,
          ease: "elastic.out(1.2, 1)",
          scrollTrigger: {
            trigger: this,
            containerAnimation: scrollTween,
            start: "left 90%",
            end: "left 10%",
            scrub: 0.5,
          },
        });
      });

      $stickers.each(function () {
        gsap.from(this, {
          scale: 0,
          yPercent: (Math.random() - 0.5) * 400,
          rotation: (Math.random() - 0.5) * 60,
          ease: "elastic.out(1.2, 1)",
          scrollTrigger: {
            trigger: this,
            containerAnimation: scrollTween,
            start: "left 90%",
            end: "left 10%",
            scrub: 0.5,
          },
        });
      });

      $arrow.each(function () {
        gsap.from(this, {
          drawSVG: "0% 0%",
          duration: 1,
          scrollTrigger: {
            trigger: this,
            containerAnimation: scrollTween,
            start: "left 90%",
            end: "left 30%",
            scrub: 0.5,
          },
        });
      });
    });
  });
}

/**
 * MWG 25
 */
function initMWG25() {
  const $cards = $(".services-card__wrap");
  if ($cards.length === 0) return; // ⛔ Not on this page

  const $container = $(".services .services__row-cards");
  const $cardContent = $cards.find(".services-card");
  const cardsLength = $cards.length;

  let currentPortion = 0;
  let containerW = $container.width();

  const elastic = { ease: "elastic.out(1, 0.75)", duration: 0.8 };

  // Update container width on resize
  $(window).on("resize", () => {
    containerW = $container.width();
  });

  // Utility to read offsets from data attributes
  function getOffset($el) {
    return {
      x: parseFloat($el.data("offset-x")) || 0,
      y: parseFloat($el.data("offset-y")) || 0,
      rot: parseFloat($el.data("offset-rot")) || 0,
    };
  }

  // Set initial transform per card
  $cards.each(function () {
    const offset = getOffset($(this));
    gsap.set(this, {
      xPercent: offset.x,
      yPercent: offset.y,
      rotation: offset.rot,
    });
  });

  $container.on("mousemove", function (e) {
    const mouseX = e.clientX - $container.offset().left;
    const percentage = mouseX / containerW;
    const activePortion = Math.ceil(percentage * cardsLength);

    if (
      currentPortion !== activePortion &&
      activePortion > 0 &&
      activePortion <= cardsLength
    ) {
      if (currentPortion !== 0) resetPortion(currentPortion - 1);
      currentPortion = activePortion;
      newPortion(currentPortion - 1);
    }
  });

  $container.on("mouseleave", function () {
    resetPortion(currentPortion - 1);
    currentPortion = 0;

    gsap.to($cardContent.toArray(), {
      xPercent: 0,
      ...elastic,
    });
  });

  function resetPortion(index) {
    if (index < 0 || index >= cardsLength) return;

    const $card = $($cards.get(index));
    const offset = getOffset($card);

    gsap.to($card[0], {
      xPercent: offset.x,
      yPercent: offset.y,
      rotation: offset.rot,
      scale: 1,
      ...elastic,
    });
  }

  function newPortion(i) {
    if (i < 0 || i >= cardsLength) return;

    gsap.to($cards.get(i), {
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      scale: 1.1,
      ...elastic,
    });

    $cardContent.each(function (index) {
      const x = index === i ? 0 : 70 / (index - i);
      gsap.to(this, {
        xPercent: x,
        ...elastic,
      });
    });
  }
}

/**
 * Osmo Marquee Scroll Direction
 */

function initMarqueeScrollDirection() {
  document
    .querySelectorAll("[data-marquee-scroll-direction-target]")
    .forEach((marquee) => {
      // Query marquee elements
      const marqueeContent = marquee.querySelector(
        "[data-marquee-collection-target]"
      );
      const marqueeScroll = marquee.querySelector(
        "[data-marquee-scroll-target]"
      );
      if (!marqueeContent || !marqueeScroll) return;

      // Get data attributes
      const {
        marqueeSpeed: speed,
        marqueeDirection: direction,
        marqueeDuplicate: duplicate,
        marqueeScrollSpeed: scrollSpeed,
      } = marquee.dataset;

      // Convert data attributes to usable types
      const marqueeSpeedAttr = parseFloat(speed);
      const marqueeDirectionAttr = direction === "right" ? 1 : -1; // 1 for right, -1 for left
      const duplicateAmount = parseInt(duplicate || 0);
      const scrollSpeedAttr = parseFloat(scrollSpeed);
      const speedMultiplier =
        window.innerWidth < 479 ? 0.25 : window.innerWidth < 991 ? 0.5 : 1;

      let marqueeSpeed =
        marqueeSpeedAttr *
        (marqueeContent.offsetWidth / window.innerWidth) *
        speedMultiplier;

      // Precompute styles for the scroll container
      marqueeScroll.style.marginLeft = `${scrollSpeedAttr * -1}%`;
      marqueeScroll.style.width = `${scrollSpeedAttr * 2 + 100}%`;

      // Duplicate marquee content
      if (duplicateAmount > 0) {
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < duplicateAmount; i++) {
          fragment.appendChild(marqueeContent.cloneNode(true));
        }
        marqueeScroll.appendChild(fragment);
      }

      // GSAP animation for marquee content
      const marqueeItems = marquee.querySelectorAll(
        "[data-marquee-collection-target]"
      );
      const animation = gsap
        .to(marqueeItems, {
          xPercent: -100, // Move completely out of view
          repeat: -1,
          duration: marqueeSpeed,
          ease: "linear",
        })
        .totalProgress(0.5);

      // Initialize marquee in the correct direction
      gsap.set(marqueeItems, {
        xPercent: marqueeDirectionAttr === 1 ? 100 : -100,
      });
      animation.timeScale(marqueeDirectionAttr); // Set correct direction
      animation.play(); // Start animation immediately

      // Set initial marquee status
      marquee.setAttribute("data-marquee-status", "normal");

      // ScrollTrigger logic for direction inversion
      ScrollTrigger.create({
        trigger: marquee,
        start: "top bottom",
        end: "bottom top",
        onUpdate: (self) => {
          const isInverted = self.direction === 1; // Scrolling down
          const currentDirection = isInverted
            ? -marqueeDirectionAttr
            : marqueeDirectionAttr;

          // Update animation direction and marquee status
          animation.timeScale(currentDirection);
          marquee.setAttribute(
            "data-marquee-status",
            isInverted ? "normal" : "inverted"
          );
        },
      });

      // Extra speed effect on scroll
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: marquee,
          start: "0% 100%",
          end: "100% 0%",
          scrub: 0,
        },
      });

      const scrollStart =
        marqueeDirectionAttr === -1 ? scrollSpeedAttr : -scrollSpeedAttr;
      const scrollEnd = -scrollStart;

      tl.fromTo(
        marqueeScroll,
        { x: `${scrollStart}vw` },
        { x: `${scrollEnd}vw`, ease: "none" }
      );
    });
}

/**
 * Flick Cards
 */

function initFlickCards() {
  const init = document.querySelector("[data-flick-cards-init]");
  if (!init) return;
  const list = init.querySelector("[data-flick-cards-list]");
  const dragger = init.querySelector("[data-flick-cards-dragger]");
  const cards = Array.from(list.querySelectorAll("[data-flick-cards-item]"));
  const mirrorList = init.querySelector("[data-flick-cards-list-mirror]");
  const mirrorCards = mirrorList
    ? Array.from(mirrorList.querySelectorAll("[data-flick-cards-item-mirror]"))
    : [];
  const total = cards.length;
  if (total < 7) return;

  let activeIdx = 0;
  const W = init.clientWidth;
  const swipeThreshold = 0.1;
  const mod = (n, m) => ((n % m) + m) % m;

  function overridePlayPause(player) {
    const origPlay = player.play.bind(player);
    const origPause = player.pause.bind(player);
    let pendingPlay = null;

    player.play = function () {
      if (!pendingPlay) {
        pendingPlay = origPlay().finally(() => {
          pendingPlay = null;
        });
      }
      return pendingPlay;
    };

    player.pause = function () {
      if (pendingPlay) {
        return pendingPlay.then(() => origPause()).catch(() => {});
      }
      return origPause();
    };
  }

  function waitForPlayerLoaded(player) {
    return new Promise((resolve) => {
      player.on("loaded", () => resolve());
    });
  }

  function waitForValidVideoDimensions(player, attempts = 10, delay = 150) {
    return new Promise((resolve, reject) => {
      const tryGet = (n) => {
        Promise.all([player.getVideoWidth(), player.getVideoHeight()])
          .then(([vw, vh]) => {
            if (vw > 0 && vh > 0) {
              resolve([vw, vh]);
            } else if (n > 0) {
              setTimeout(() => tryGet(n - 1), delay);
            } else {
              reject("Failed to get video dimensions");
            }
          })
          .catch(reject);
      };
      tryGet(attempts);
    });
  }

  const slides = cards.map((card) => {
    const wrap = card.querySelector("[data-flick-cards-video]");
    if (!wrap) return null;
    const vidId = wrap.dataset.flickCardsVideoId;
    if (!vidId) return null;
    const iframe = wrap.querySelector("iframe[data-flick-cards-video-iframe]");
    if (!iframe) return null;
    wrap.setAttribute("data-flick-cards-video-status", "not-active");
    return { wrap, iframe, vidId, player: null, loaded: false };
  });

  function loadSlide(i) {
    const idx = mod(i, total);
    const slide = slides[idx];
    if (!slide) return Promise.resolve();
    if (slide.loaded) return Promise.resolve(slide.player);

    slide.loaded = true;
    // Inject Vimeo URL
    slide.iframe.src =
      `https://player.vimeo.com/video/${slide.vidId}` +
      `?api=1&muted=1&loop=1&background=1`;

    slide.player = new Vimeo.Player(slide.iframe, {
      id: slide.vidId,
      muted: true,
      loop: true,
      autoplay: false,
    });

    overridePlayPause(slide.player);

    // resolve when we actually hit “play”
    return new Promise((resolve) => {
      function onPlay() {
        slide.wrap.setAttribute("data-flick-cards-video-status", "active");

        // ─── Wait for metadata and size the video ───
        waitForPlayerLoaded(slide.player)
          .then(() => waitForValidVideoDimensions(slide.player))
          .then(([vw, vh]) => {
            const { width: cw, height: ch } =
              slide.wrap.getBoundingClientRect();
            const videoRatio = vw / vh;
            const cardRatio = cw / ch;
            let wPerc, hPerc;
            if (videoRatio > cardRatio) {
              hPerc = 100;
              wPerc = (videoRatio / cardRatio) * 100;
            } else {
              wPerc = 100;
              hPerc = (cardRatio / videoRatio) * 100;
            }
            slide.iframe.style.width = `${wPerc}%`;
            slide.iframe.style.height = `${hPerc}%`;
          });

        resolve(slide.player);
        slide.player.off("play", onPlay);
      }

      slide.player.on("play", onPlay);
      slide.player.play();
    });
  }

  loadSlide(activeIdx)
    .then((player) => {
      // kick off neighbors
      [activeIdx - 1, activeIdx + 1].forEach(loadSlide);
      return player;
    })
    .then(() => {
      // now safe‐pause every non-active video
      slides.forEach((s, i) => {
        if (!s || !s.loaded || i === activeIdx) return;
        s.player.pause();
      });
    });

  const io = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        const i = slides.findIndex((s) => s && s.iframe === entry.target);
        if (i !== activeIdx) return;
        entry.isIntersecting
          ? slides[i].player.play()
          : slides[i].player.pause();
      });
    },
    { threshold: 0 }
  );
  slides.forEach((s) => {
    if (s) io.observe(s.iframe);
  });

  function getCfg(i, ci) {
    let diff = i - ci;
    if (diff > total / 2) diff -= total;
    else if (diff < -total / 2) diff += total;
    switch (diff) {
      case 0:
        return { x: 0, y: 0, rot: 0, s: 1, o: 1, z: 5 };
      case 1:
        return { x: 25, y: 1, rot: 10, s: 0.9, o: 1, z: 4 };
      case -1:
        return { x: -25, y: 1, rot: -10, s: 0.9, o: 1, z: 4 };
      case 2:
        return { x: 45, y: 5, rot: 15, s: 0.8, o: 1, z: 3 };
      case -2:
        return { x: -45, y: 5, rot: -15, s: 0.8, o: 1, z: 3 };
      default:
        const dir = diff > 0 ? 1 : -1;
        return { x: 55 * dir, y: 5, rot: 20 * dir, s: 0.6, o: 0, z: 2 };
    }
  }

  function renderDiscrete(ci) {
    cards.forEach((card, i) => {
      const cfg = getCfg(i, ci);
      let status;
      if (cfg.x === 0) status = "active";
      else if (cfg.x === 25) status = "2-after";
      else if (cfg.x === -25) status = "2-before";
      else if (cfg.x === 45) status = "3-after";
      else if (cfg.x === -45) status = "3-before";
      else status = "hidden";

      card.setAttribute("data-flick-cards-item-status", status);
      card.style.zIndex = cfg.z;
      if (mirrorCards[i]) {
        mirrorCards[i].setAttribute(
          "data-flick-cards-item-status-mirror",
          status
        );
      }

      gsap.to(card, {
        duration: 0.6,
        ease: "elastic.out(1.2,1)",
        xPercent: cfg.x,
        yPercent: cfg.y,
        rotation: cfg.rot,
        scale: cfg.s,
        opacity: cfg.o,
      });
    });
  }
  renderDiscrete(activeIdx);

  Draggable.create(dragger, {
    type: "x",
    cursor: "inherit",
    activeCursor: "inherit",
    bounds: { minX: -W / 2, maxX: W / 2 },
    edgeResistance: 0.8,
    inertia: false,

    onPress() {
      init.setAttribute("data-flick-drag-status", "grabbing");
    },

    onDrag() {
      const raw = this.x / W;
      const prog = Math.min(1, Math.abs(raw));
      const dir = raw > 0 ? -1 : 1;
      const nextCi = mod(activeIdx + dir, total);

      cards.forEach((card, i) => {
        const a = getCfg(i, activeIdx);
        const b = getCfg(i, nextCi);
        const mix = (prop) => a[prop] + (b[prop] - a[prop]) * prog;
        gsap.set(card, {
          xPercent: mix("x"),
          yPercent: mix("y"),
          rotation: mix("rot"),
          scale: mix("s"),
          opacity: mix("o"),
        });
      });
    },

    onRelease() {
      const raw = this.x / W;
      let shift = 0;
      if (raw > swipeThreshold) shift = -1;
      else if (raw < -swipeThreshold) shift = 1;

      const prevIdx = activeIdx;
      activeIdx = mod(activeIdx + shift, total);
      renderDiscrete(activeIdx);

      // Load new + neighbors
      loadSlide(activeIdx).then(() => {
        [activeIdx - 1, activeIdx + 1].forEach(loadSlide);
      });

      // Safe‐pause old & safe‐play new
      const old = slides[prevIdx],
        nw = slides[activeIdx];
      if (old) old.player.pause();
      if (nw) nw.player.play();

      // Snap back
      gsap.to(this.target, {
        x: 0,
        duration: 0.3,
        ease: "power1.out",
      });
      init.setAttribute("data-flick-drag-status", "grab");
    },
  });
}

/**
 * Vimeo Thumbnail Video
 */
function initVimeoThumbnailVideo() {
  const isTouch = window.matchMedia(
    "(hover: none) and (pointer: coarse)"
  ).matches;
  const queue = Array.from(document.querySelectorAll("[data-thumbnail-video]"));

  function loadNext(index = 0) {
    if (index >= queue.length) return;

    const videoEl = queue[index];
    const videoId = videoEl.getAttribute("data-thumbnail-video-id");
    const iframe = videoEl.querySelector("[data-thumbnail-video-iframe]");
    const wrapper = videoEl.querySelector("[data-thumbnail-video-wrapper]");
    let player = null;
    let hasLoaded = false;
    let isHovered = false;

    if (!videoId || !iframe || !wrapper) {
      loadNext(index + 1); // skip and continue
      return;
    }

    iframe.setAttribute(
      "src",
      `https://player.vimeo.com/video/${videoId}?background=1&autoplay=1&muted=1&playsinline=1`
    );

    player = new Vimeo.Player(iframe);

    player.on("play", () => {
      if (hasLoaded) return;
      hasLoaded = true;

      Promise.all([player.getVideoWidth(), player.getVideoHeight()]).then(
        ([videoW, videoH]) => {
          const wrapperW = wrapper.offsetWidth;
          const wrapperH = wrapper.offsetHeight;

          const videoRatio = videoW / videoH;
          const wrapperRatio = wrapperW / wrapperH;

          const finalW =
            videoRatio > wrapperRatio ? wrapperH * videoRatio : wrapperW;
          const finalH =
            videoRatio > wrapperRatio ? wrapperH : wrapperW / videoRatio;

          const widthPercent = (finalW / wrapperW) * 100;
          const heightPercent = (finalH / wrapperH) * 100;

          iframe.style.width = widthPercent + "%";
          iframe.style.height = heightPercent + "%";

          videoEl.setAttribute(
            "data-thumbnail-video-status",
            isTouch || isHovered ? "active" : "not-active"
          );

          // 👇 Load next in queue
          loadNext(index + 1);
        }
      );
    });

    if (!isTouch) {
      videoEl.addEventListener("mouseenter", () => {
        isHovered = true;

        if (!hasLoaded) {
          videoEl.setAttribute("data-thumbnail-video-status", "loading");
        } else {
          videoEl.setAttribute("data-thumbnail-video-status", "active");
          player?.play();
        }
      });

      videoEl.addEventListener("mouseleave", () => {
        isHovered = false;

        if (hasLoaded) {
          videoEl.setAttribute("data-thumbnail-video-status", "not-active");
          player?.pause();
        } else {
          videoEl.setAttribute("data-thumbnail-video-status", "not-active");
        }
      });
    }

    if (isTouch) {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (!hasLoaded) return;

            if (entry.isIntersecting) {
              player?.play();
            } else {
              player?.pause();
            }
          });
        },
        { threshold: 0 }
      );

      observer.observe(videoEl);
    }
  }

  // Start with the first
  loadNext(0);
}

/**
 * Team Grid Cycle
 */
function initTeamGridCycle() {
  const $grid = $("[data-team-grid-init]");
  if (!$grid.length) return;

  // Step 1: Collect all image cycle items
  const $items = $grid.find("[data-image-cycle-item]").clone().toArray();

  // Step 2: Remove all .team-card__remove elements inside the grid
  $grid.find(".team-card__remove").remove();

  // Step 3: Find all target containers
  const $targets = $grid.find(".team-card__target");
  const totalTargets = $targets.length;
  if (totalTargets === 0) return;

  // Step 4: Shuffle items
  const shuffled = $items.sort(() => Math.random() - 0.5);

  // Step 5: Distribute shuffled items evenly across targets
  shuffled.forEach((item, index) => {
    const $target = $targets.eq(index % totalTargets);
    $target.append(item);
  });

  initImageCycleSequential();
}

/**
 * Image Cycle (Osmo)
 */
function initImageCycleSequential() {
  const groups = Array.from(document.querySelectorAll("[data-image-cycle]"));

  if (!groups.length) return;

  // Parse and sort by data-image-cycle value (number)
  const sortedGroups = groups
    .map((el) => ({
      el,
      order: parseInt(el.getAttribute("data-image-cycle"), 10) || 0,
    }))
    .filter((group) => group.order > 0)
    .sort((a, b) => a.order - b.order);

  let currentGroupIndex = 0;
  const globalInterval = 750; // 1 second per group

  // Init each group: set first item to active
  sortedGroups.forEach((group) => {
    const items = group.el.querySelectorAll("[data-image-cycle-item]");
    if (items.length < 2) return;
    items.forEach((item, i) => {
      item.setAttribute(
        "data-image-cycle-item",
        i === 0 ? "active" : "not-active"
      );
    });
  });

  // Rotate one group at a time
  function cycleNextGroup() {
    const group = sortedGroups[currentGroupIndex];
    if (!group) return;

    const items = group.el.querySelectorAll("[data-image-cycle-item]");
    if (items.length < 2) return;

    let activeIndex = -1;
    items.forEach((item, i) => {
      if (item.getAttribute("data-image-cycle-item") === "active") {
        activeIndex = i;
      }
    });

    const prevIndex = activeIndex;
    const nextIndex = (activeIndex + 1) % items.length;

    items[prevIndex].setAttribute("data-image-cycle-item", "previous");
    setTimeout(() => {
      items[prevIndex].setAttribute("data-image-cycle-item", "not-active");
    }, globalInterval);

    items[nextIndex].setAttribute("data-image-cycle-item", "active");

    // Go to next group
    currentGroupIndex = (currentGroupIndex + 1) % sortedGroups.length;
  }

  // Start the global interval
  setInterval(cycleNextGroup, globalInterval);
}

/**
 * CSS Marquee (Osmo) — jQuery version with shuffle, distribution, and theme tagging
 */
function initCSSMarquee() {
  const pixelsPerSecond = 75;
  const themeCycle = ["a", "b", "c", "d"];

  $("[data-css-marquee-init]").each(function () {
    const $init = $(this);
    const $marquees = $init.find("[data-css-marquee]");
    const items = [];

    // Collect and remove all items
    $marquees.find("[data-css-marquee-item]").each(function () {
      items.push(this);
      $(this).remove();
    });

    // Shuffle utility
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    const shuffledItems = shuffleArray(items.slice());
    const $lists = $marquees.find("[data-css-marquee-list]");
    const groupCount = $lists.length;

    // Distribute and assign data-logo-theme
    shuffledItems.forEach((item, index) => {
      const groupIndex = index % groupCount;
      const $targetList = $lists.eq(groupIndex);

      $targetList.append(item);

      const $itemsInList = $targetList.find("[data-css-marquee-item]");
      $itemsInList.each(function (i) {
        $(this).attr("data-logo-theme", themeCycle[i % themeCycle.length]);
      });
    });

    // Duplicate each list
    $lists.each(function () {
      const $list = $(this);
      const $clone = $list.clone();
      $list.parent().append($clone);
    });

    // Observer to toggle animation
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          $(entry.target)
            .find("[data-css-marquee-list]")
            .css(
              "animation-play-state",
              entry.isIntersecting ? "running" : "paused"
            );
        });
      },
      { threshold: 0 }
    );

    // Set animation duration
    $init.find("[data-css-marquee-list]").each(function () {
      const $list = $(this);
      $list.css({
        animationDuration: $list.outerHeight() / pixelsPerSecond + "s",
        animationPlayState: "paused",
      });
    });

    // Observe each marquee container
    $marquees.each(function () {
      observer.observe(this);
    });
  });
}

/**
 * Basic GSAP Slider (Osmo)
 */
function initBasicGSAPSlider() {
  document.querySelectorAll("[data-gsap-slider-init]").forEach((root) => {
    if (root._sliderDraggable) root._sliderDraggable.kill();

    const collection = root.querySelector("[data-gsap-slider-collection]");
    const track = root.querySelector("[data-gsap-slider-list]");
    const items = Array.from(root.querySelectorAll("[data-gsap-slider-item]"));
    const controls = Array.from(
      root.querySelectorAll("[data-gsap-slider-control]")
    );

    // Inject aria attributes
    root.setAttribute("role", "region");
    root.setAttribute("aria-roledescription", "carousel");
    root.setAttribute("aria-label", "Slider");
    collection.setAttribute("role", "group");
    collection.setAttribute("aria-roledescription", "Slides List");
    collection.setAttribute("aria-label", "Slides");
    items.forEach((slide, i) => {
      slide.setAttribute("role", "group");
      slide.setAttribute("aria-roledescription", "Slide");
      slide.setAttribute("aria-label", `Slide ${i + 1} of ${items.length}`);
      slide.setAttribute("aria-hidden", "true");
      slide.setAttribute("aria-selected", "false");
      slide.setAttribute("tabindex", "-1");
    });
    controls.forEach((btn) => {
      const dir = btn.getAttribute("data-gsap-slider-control");
      btn.setAttribute("role", "button");
      btn.setAttribute(
        "aria-label",
        dir === "prev" ? "Previous Slide" : "Next Slide"
      );
      btn.disabled = true;
      btn.setAttribute("aria-disabled", "true");
    });

    // Determine if slider runs
    const styles = getComputedStyle(root);
    const statusVar = styles.getPropertyValue("--slider-status").trim();
    let spvVar = parseFloat(styles.getPropertyValue("--slider-spv"));
    const rect = items[0].getBoundingClientRect();
    const marginRight = parseFloat(getComputedStyle(items[0]).marginRight);
    const slideW = rect.width + marginRight;
    if (isNaN(spvVar)) {
      spvVar = collection.clientWidth / slideW;
    }
    const spv = Math.max(1, Math.min(spvVar, items.length));
    const sliderEnabled = statusVar === "on" && spv < items.length;
    root.setAttribute(
      "data-gsap-slider-status",
      sliderEnabled ? "active" : "not-active"
    );

    if (!sliderEnabled) {
      // Teardown when disabled
      track.removeAttribute("style");
      track.onmouseenter = null;
      track.onmouseleave = null;
      track.removeAttribute("data-gsap-slider-list-status");
      root.removeAttribute("role");
      root.removeAttribute("aria-roledescription");
      root.removeAttribute("aria-label");
      collection.removeAttribute("role");
      collection.removeAttribute("aria-roledescription");
      collection.removeAttribute("aria-label");
      items.forEach((slide) => {
        slide.removeAttribute("role");
        slide.removeAttribute("aria-roledescription");
        slide.removeAttribute("aria-label");
        slide.removeAttribute("aria-hidden");
        slide.removeAttribute("aria-selected");
        slide.removeAttribute("tabindex");
        slide.removeAttribute("data-gsap-slider-item-status");
      });
      controls.forEach((btn) => {
        btn.disabled = false;
        btn.removeAttribute("role");
        btn.removeAttribute("aria-label");
        btn.removeAttribute("aria-disabled");
        btn.removeAttribute("data-gsap-slider-control-status");
      });
      return;
    }

    // Track hover state
    track.onmouseenter = () => {
      track.setAttribute("data-gsap-slider-list-status", "grab");
    };
    track.onmouseleave = () => {
      track.removeAttribute("data-gsap-slider-list-status");
    };

    //Ccalculate bounds and snap points
    const vw = collection.clientWidth;
    const tw = track.scrollWidth;
    const maxScroll = Math.max(tw - vw, 0);
    const minX = -maxScroll;
    const maxX = 0;
    const maxIndex = maxScroll / slideW;
    const full = Math.floor(maxIndex);
    const snapPoints = [];
    for (let i = 0; i <= full; i++) {
      snapPoints.push(-i * slideW);
    }
    if (full < maxIndex) {
      snapPoints.push(-maxIndex * slideW);
    }

    let activeIndex = 0;
    const setX = gsap.quickSetter(track, "x", "px");
    let collectionRect = collection.getBoundingClientRect();

    function updateStatus(x) {
      if (x > maxX || x < minX) {
        return;
      }

      // Clamp and find closest snap
      const calcX = x > maxX ? maxX : x < minX ? minX : x;
      let closest = snapPoints[0];
      snapPoints.forEach((pt) => {
        if (Math.abs(pt - calcX) < Math.abs(closest - calcX)) {
          closest = pt;
        }
      });
      activeIndex = snapPoints.indexOf(closest);

      // Update Slide Attributes
      items.forEach((slide, i) => {
        const r = slide.getBoundingClientRect();
        const leftEdge = r.left - collectionRect.left;
        const slideCenter = leftEdge + r.width / 2;
        const inView = slideCenter > 0 && slideCenter < collectionRect.width;
        const status =
          i === activeIndex ? "active" : inView ? "inview" : "not-active";

        slide.setAttribute("data-gsap-slider-item-status", status);
        slide.setAttribute(
          "aria-selected",
          i === activeIndex ? "true" : "false"
        );
        slide.setAttribute("aria-hidden", inView ? "false" : "true");
        slide.setAttribute("tabindex", i === activeIndex ? "0" : "-1");
      });

      // Update Controls
      controls.forEach((btn) => {
        const dir = btn.getAttribute("data-gsap-slider-control");
        const can =
          dir === "prev"
            ? activeIndex > 0
            : activeIndex < snapPoints.length - 1;

        btn.disabled = !can;
        btn.setAttribute("aria-disabled", can ? "false" : "true");
        btn.setAttribute(
          "data-gsap-slider-control-status",
          can ? "active" : "not-active"
        );
      });
    }

    controls.forEach((btn) => {
      const dir = btn.getAttribute("data-gsap-slider-control");
      btn.addEventListener("click", () => {
        if (btn.disabled) return;
        const delta = dir === "next" ? 1 : -1;
        const target = activeIndex + delta;
        gsap.to(track, {
          duration: 0.4,
          x: snapPoints[target],
          onUpdate: () => updateStatus(gsap.getProperty(track, "x")),
        });
      });
    });

    // Initialize Draggable
    root._sliderDraggable = Draggable.create(track, {
      type: "x",
      cursor: "inherit",
      activeCursor: "inherit",
      inertia: true,
      bounds: { minX, maxX },
      throwResistance: 2000,
      dragResistance: 0.05,
      maxDuration: 0.6,
      minDuration: 0.2,
      edgeResistance: 0.75,
      snap: { x: snapPoints, duration: 0.4 },
      onPress() {
        track.setAttribute("data-gsap-slider-list-status", "grabbing");
        collectionRect = collection.getBoundingClientRect();
      },
      onDrag() {
        setX(this.x);
        updateStatus(this.x);
      },
      onThrowUpdate() {
        setX(this.x);
        updateStatus(this.x);
      },
      onThrowComplete() {
        setX(this.endX);
        updateStatus(this.endX);
        track.setAttribute("data-gsap-slider-list-status", "grab");
      },
      onRelease() {
        setX(this.x);
        updateStatus(this.x);
        track.setAttribute("data-gsap-slider-list-status", "grab");
      },
    })[0];

    // Initial state
    setX(0);
    updateStatus(0);
  });
}

// Debouncer: Returns a debounced fn that only fires when window.innerWidth changes
function debounceOnWidthChange(fn, ms) {
  let last = innerWidth,
    timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      if (innerWidth !== last) {
        last = innerWidth;
        fn.apply(this, args);
      }
    }, ms);
  };
}

window.addEventListener(
  "resize",
  debounceOnWidthChange(initBasicGSAPSlider, 200)
);

/**
 * Change Page Title on Leave (Osmo)
 */
function initPageLeaveTitle() {
  const documentTitleStore = document.title;
  const documentTitleOnBlur = "Hey, over here! 👋 - Truus"; // Define your custom title here

  // Set original title if user is on the site
  window.addEventListener("focus", () => {
    document.title = documentTitleStore;
  });

  // If user leaves tab, set the alternative title
  window.addEventListener("blur", () => {
    document.title = documentTitleOnBlur;
  });
}

/**
 * Update Count Osmo
 */
function initDisplayCount() {
  document.querySelectorAll("[data-count-group]").forEach((group) => {
    const name = group.dataset.countGroup;
    const count = group.querySelectorAll("[data-count-item]").length;
    const display = document.querySelector(`[data-count-display="${name}"]`);
    document
      .querySelectorAll(`[data-count-display="${name}"]`)
      .forEach((display) => (display.textContent = count));
  });
}

/**
 * Scrolltrigger Animations Desktop + Mobile
 */
function initScrolltriggerAnimations() {
  $('[data-scroll-animation="draw"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this).find("path");

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "0% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.fromTo(
      targetElement,
      {
        drawSVG: "0% 0%",
      },
      {
        delay: 0.1,
        drawSVG: "0% 100%",
        duration: 0.8,
        clearProps: "all",
      }
    );
  });

  $('[data-scroll-animation="draw-stagger"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this).find("path");

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "0% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.fromTo(
      targetElement,
      {
        drawSVG: "0% 0%",
      },
      {
        delay: 0.1,
        drawSVG: "0% 100%",
        duration: 0.8,
        stagger: 0.4,
        clearProps: "all",
      }
    );
  });

  $('[data-scroll-animation="sticker"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this);

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "0% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.from(targetElement, {
      xPercent: () => gsap.utils.random(-45, 45),
      yPercent: () => gsap.utils.random(-45, 45),
      rotation: () => gsap.utils.random(-45, 45),
      scale: 0,
      duration: 0.8,
      ease: "elastic.out(1,0.75)",
      clearProps: "all",
    });
  });

  $('[data-scroll-animation="sticker-draw"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this)
      .find('[data-scroll-animation-target="draw"]')
      .find("path");
    let targetElementSticker = $(this).find(
      '[data-scroll-animation-target="sticker"]'
    );

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "25% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.from(targetElementSticker, {
      delay: 0.1,
      xPercent: -45,
      yPercent: 45,
      rotate: -45,
      scale: 0,
      duration: 0.8,
      ease: "elastic.out(1,0.75)",
      clearProps: "all",
    });

    tl.fromTo(
      targetElement,
      {
        drawSVG: "0% 0%",
      },
      {
        drawSVG: "0% 100%",
        duration: 0.8,
        clearProps: "all",
      },
      "<"
    );
  });

  $('[data-scroll-animation="draw-sticker"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this)
      .find('[data-scroll-animation-target="draw"]')
      .find("path");
    let targetElementSticker = $(this).find(
      '[data-scroll-animation-target="sticker"]'
    );

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "25% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.fromTo(
      targetElement,
      {
        drawSVG: "0% 0%",
      },
      {
        delay: 0.1,
        drawSVG: "0% 100%",
        duration: 0.8,
        clearProps: "all",
      }
    );

    tl.from(
      targetElementSticker,
      {
        xPercent: -45,
        yPercent: 45,
        rotate: -45,
        scale: 0,
        duration: 0.8,
        ease: "elastic.out(1,0.75)",
        clearProps: "all",
      },
      "< 0.5"
    );
  });

  $('[data-scroll-animation="stickers"]').each(function () {
    let triggerElement = $(this);
    let targetElement = $(this).find("[data-scroll-animation-target]");

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "0% 100%",
        end: "100% 0%",
        toggleActions: "play none none reset",
      },
    });

    tl.from(targetElement, {
      xPercent: () => gsap.utils.random(-45, 45),
      yPercent: () => gsap.utils.random(-45, 45),
      rotation: () => gsap.utils.random(-45, 45),
      scale: 0,
      duration: 0.8,
      ease: "elastic.out(1,0.75)",
      stagger: {
        amount: 1,
        from: "random",
      },
      clearProps: "all",
    });
  });
}
